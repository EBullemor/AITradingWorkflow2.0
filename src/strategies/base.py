"""
Base Strategy Module

Defines the abstract base class for all strategy pods.
Each strategy must implement the generate_signals method.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field, asdict
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import pandas as pd
import yaml
from loguru import logger


class SignalDirection(Enum):
    """Signal direction."""
    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"


class SignalStrength(Enum):
    """Signal conviction level."""
    WEAK = "WEAK"           # 0.0 - 0.3
    MODERATE = "MODERATE"   # 0.3 - 0.6
    STRONG = "STRONG"       # 0.6 - 0.8
    VERY_STRONG = "VERY_STRONG"  # 0.8 - 1.0


class SignalStatus(Enum):
    """Signal lifecycle status."""
    ACTIVE = "ACTIVE"
    EXPIRED = "EXPIRED"
    PROMOTED = "PROMOTED"  # Promoted to final recommendation
    REJECTED = "REJECTED"  # Rejected by aggregator


@dataclass
class Signal:
    """
    Trading signal generated by a strategy pod.
    
    This is the output of each strategy - multiple signals from different
    strategies are aggregated into final recommendations.
    """
    # Core fields
    instrument: str
    direction: SignalDirection
    strength: float  # 0.0 to 1.0
    
    # Strategy info
    strategy_name: str
    strategy_pod: str
    
    # Timing
    generated_at: datetime
    valid_until: datetime
    
    # Price levels (optional but recommended)
    entry_price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit_1: Optional[float] = None
    take_profit_2: Optional[float] = None
    
    # Risk info
    risk_reward_ratio: Optional[float] = None
    position_size_pct: Optional[float] = None  # Suggested position size
    
    # Rationale
    rationale: str = ""
    key_factors: List[str] = field(default_factory=list)
    
    # Context
    regime: Optional[str] = None
    confidence_drivers: Dict[str, float] = field(default_factory=dict)
    
    # Metadata
    signal_id: Optional[str] = None
    status: SignalStatus = SignalStatus.ACTIVE
    
    def __post_init__(self):
        """Validate and compute derived fields."""
        # Generate signal ID if not provided
        if self.signal_id is None:
            self.signal_id = f"{self.strategy_pod}_{self.instrument}_{self.generated_at.strftime('%Y%m%d%H%M%S')}"
        
        # Compute risk-reward if not provided
        if self.risk_reward_ratio is None and all([
            self.entry_price, self.stop_loss, self.take_profit_1
        ]):
            risk = abs(self.entry_price - self.stop_loss)
            reward = abs(self.take_profit_1 - self.entry_price)
            if risk > 0:
                self.risk_reward_ratio = reward / risk
    
    @property
    def strength_category(self) -> SignalStrength:
        """Get strength as category."""
        if self.strength >= 0.8:
            return SignalStrength.VERY_STRONG
        elif self.strength >= 0.6:
            return SignalStrength.STRONG
        elif self.strength >= 0.3:
            return SignalStrength.MODERATE
        else:
            return SignalStrength.WEAK
    
    @property
    def is_active(self) -> bool:
        """Check if signal is still active."""
        return (
            self.status == SignalStatus.ACTIVE and
            datetime.now() < self.valid_until
        )
    
    def to_dict(self) -> Dict:
        """Convert to dictionary for serialization."""
        return {
            "signal_id": self.signal_id,
            "instrument": self.instrument,
            "direction": self.direction.value,
            "strength": self.strength,
            "strength_category": self.strength_category.value,
            "strategy_name": self.strategy_name,
            "strategy_pod": self.strategy_pod,
            "generated_at": self.generated_at.isoformat(),
            "valid_until": self.valid_until.isoformat(),
            "entry_price": self.entry_price,
            "stop_loss": self.stop_loss,
            "take_profit_1": self.take_profit_1,
            "take_profit_2": self.take_profit_2,
            "risk_reward_ratio": self.risk_reward_ratio,
            "position_size_pct": self.position_size_pct,
            "rationale": self.rationale,
            "key_factors": self.key_factors,
            "regime": self.regime,
            "confidence_drivers": self.confidence_drivers,
            "status": self.status.value,
        }
    
    def format_for_display(self) -> str:
        """Format signal for human-readable display."""
        direction_emoji = "ðŸŸ¢" if self.direction == SignalDirection.LONG else "ðŸ”´"
        
        lines = [
            f"{direction_emoji} {self.direction.value} {self.instrument}",
            f"   Strength: {self.strength:.1%} ({self.strength_category.value})",
            f"   Strategy: {self.strategy_name}",
        ]
        
        if self.entry_price:
            lines.append(f"   Entry: {self.entry_price:.5f}")
        if self.stop_loss:
            lines.append(f"   Stop: {self.stop_loss:.5f}")
        if self.take_profit_1:
            lines.append(f"   Target: {self.take_profit_1:.5f}")
        if self.risk_reward_ratio:
            lines.append(f"   R:R: {self.risk_reward_ratio:.1f}:1")
        
        if self.rationale:
            lines.append(f"   Rationale: {self.rationale}")
        
        return "\n".join(lines)


class BaseStrategy(ABC):
    """
    Abstract base class for all strategy pods.
    
    Each strategy must implement:
    - generate_signals(): Main signal generation logic
    
    Optional overrides:
    - validate_features(): Check required features are present
    - get_required_features(): List features this strategy needs
    """
    
    def __init__(
        self,
        config: Dict[str, Any],
        name: Optional[str] = None
    ):
        """
        Initialize strategy.
        
        Args:
            config: Strategy configuration dictionary
            name: Strategy name (defaults to class name)
        """
        self.config = config
        self.name = name or self.__class__.__name__
        self.pod_name = config.get("pod_name", self.name)
        
        # Common config
        self.enabled = config.get("enabled", True)
        self.instruments = config.get("instruments", [])
        self.max_signals_per_run = config.get("max_signals_per_run", 5)
        self.signal_validity_hours = config.get("signal_validity_hours", 24)
        
        logger.info(f"Initialized strategy: {self.name}")
    
    @abstractmethod
    def generate_signals(
        self,
        features: Dict[str, pd.DataFrame],
        macro_data: Optional[pd.DataFrame] = None,
        news_summary: Optional[Dict] = None,
        as_of_date: Optional[datetime] = None
    ) -> List[Signal]:
        """
        Generate trading signals based on features and market data.
        
        Args:
            features: Dictionary mapping instrument to features DataFrame
            macro_data: Macro indicators (VIX, DXY, etc.)
            news_summary: Summarized news from LLM (optional)
            as_of_date: Reference date (defaults to now)
        
        Returns:
            List of Signal objects
        """
        pass
    
    def get_required_features(self) -> List[str]:
        """
        Get list of required feature columns.
        
        Override in subclasses to specify required features.
        """
        return []
    
    def validate_features(
        self,
        features: Dict[str, pd.DataFrame]
    ) -> bool:
        """
        Validate that required features are present.
        
        Args:
            features: Features dictionary
        
        Returns:
            True if all required features present
        """
        required = self.get_required_features()
        if not required:
            return True
        
        for instrument, df in features.items():
            missing = [f for f in required if f not in df.columns]
            if missing:
                logger.warning(
                    f"Strategy {self.name}: Missing features for {instrument}: {missing}"
                )
                return False
        
        return True
    
    def _create_signal(
        self,
        instrument: str,
        direction: SignalDirection,
        strength: float,
        rationale: str,
        key_factors: List[str],
        entry_price: Optional[float] = None,
        stop_loss: Optional[float] = None,
        take_profit_1: Optional[float] = None,
        take_profit_2: Optional[float] = None,
        regime: Optional[str] = None,
        confidence_drivers: Optional[Dict[str, float]] = None,
        as_of_date: Optional[datetime] = None
    ) -> Signal:
        """
        Helper to create a properly formatted Signal.
        
        Args:
            instrument: Trading instrument
            direction: LONG or SHORT
            strength: Signal strength 0-1
            rationale: Human-readable rationale
            key_factors: List of key factors driving the signal
            entry_price: Suggested entry price
            stop_loss: Stop loss level
            take_profit_1: First take profit target
            take_profit_2: Second take profit target
            regime: Current market regime
            confidence_drivers: Breakdown of confidence by factor
            as_of_date: Signal generation time
        
        Returns:
            Signal object
        """
        if as_of_date is None:
            as_of_date = datetime.now()
        
        valid_until = as_of_date + pd.Timedelta(hours=self.signal_validity_hours)
        
        return Signal(
            instrument=instrument,
            direction=direction,
            strength=min(max(strength, 0.0), 1.0),  # Clamp to 0-1
            strategy_name=self.name,
            strategy_pod=self.pod_name,
            generated_at=as_of_date,
            valid_until=valid_until,
            entry_price=entry_price,
            stop_loss=stop_loss,
            take_profit_1=take_profit_1,
            take_profit_2=take_profit_2,
            rationale=rationale,
            key_factors=key_factors,
            regime=regime,
            confidence_drivers=confidence_drivers or {},
        )


def load_strategy_config(
    strategy_name: str,
    config_dir: Optional[Path] = None
) -> Dict:
    """
    Load strategy configuration from YAML.
    
    Args:
        strategy_name: Name of strategy (matches YAML filename)
        config_dir: Config directory path
    
    Returns:
        Configuration dictionary
    """
    if config_dir is None:
        config_dir = Path(__file__).parent.parent.parent / "config"
    
    # Try strategy-specific config first
    config_file = config_dir / f"{strategy_name}.yaml"
    
    if not config_file.exists():
        # Fall back to strategies.yaml
        config_file = config_dir / "strategies.yaml"
    
    if not config_file.exists():
        logger.warning(f"No config found for {strategy_name}, using defaults")
        return {}
    
    with open(config_file) as f:
        config = yaml.safe_load(f)
    
    # Extract strategy-specific section if present
    if strategy_name in config:
        return config[strategy_name]
    
    if "strategies" in config and strategy_name in config["strategies"]:
        return config["strategies"][strategy_name]
    
    return config
